/*
Copyright SecureKey Technologies Inc. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package kms

import (
	"crypto/ed25519"
	"io"

	"github.com/btcsuite/btcutil/base58"

	"github.com/hyperledger/aries-framework-go/pkg/didcomm/common/transport"
	"github.com/hyperledger/aries-framework-go/pkg/doc/did"
	"github.com/hyperledger/aries-framework-go/pkg/internal/cryptoutil"
	"github.com/hyperledger/aries-framework-go/pkg/kms"
)

// CloseableKMS mock Key Management Service (KMS)
type CloseableKMS struct {
	CreateKeySetValue   string
	CreateKeyErr        error
	FindVerKeyValue     int
	FindVerKeyErr       error
	SignMessageValue    []byte
	SignMessageErr      error
	DecryptMessageValue []byte
	DecryptMessageErr   error
	PackValue           []byte
	PackErr             error
	UnpackValue         *transport.Envelope
	UnpackErr           error
	MockDID             *did.Doc
	EncryptionKeyValue  []byte
	EncryptionKeyErr    error
}

// Close previously-opened KMS, removing it if so configured.
func (m *CloseableKMS) Close() error {
	return nil
}

// CreateKeySet create a new public/private encryption and signature key pairs combo.
func (m *CloseableKMS) CreateKeySet() (string, string, error) {
	return m.CreateKeySetValue, m.CreateKeySetValue, m.CreateKeyErr
}

// FindVerKey return a verification key index from the list of candidates
func (m *CloseableKMS) FindVerKey(candidateKeys [][]byte) (int, error) {
	return m.FindVerKeyValue, m.FindVerKeyErr
}

// FindVerKeyFromEncryptionKeys return an encryption key index and its corresponding verification (signing) key which is
// set as empty for this mock, from the list of candidateKeys which are public encryption keys
func (m *CloseableKMS) FindVerKeyFromEncryptionKeys(candidateKeys [][]byte) (int, string, error) {
	return m.FindVerKeyValue, "", m.FindVerKeyErr
}

// SignMessage sign a message using the private key associated with a given verification key.
func (m *CloseableKMS) SignMessage(message []byte, fromVerKey string) ([]byte, error) {
	return m.SignMessageValue, m.SignMessageErr
}

// DeriveKEK derives a key encryption key from two keys
// mocked to return empty derived KEK
func (m *CloseableKMS) DeriveKEK(alg, apu, fromKey, toPubKey []byte) ([]byte, error) { // nolint:lll
	return []byte(""), nil
}

// GetEncryptionKey will return the public encryption key corresponding to the public verKey argument
func (m *CloseableKMS) GetEncryptionKey(verKey []byte) ([]byte, error) {
	return m.EncryptionKeyValue, m.EncryptionKeyErr
}

// ConvertToEncryptionKey converts the keypair containing the given verkey to an encryption keypair
func (m *CloseableKMS) ConvertToEncryptionKey(key []byte) ([]byte, error) {
	return m.EncryptionKeyValue, m.EncryptionKeyErr
}

// CreateKeys will create a set of cryptoutil.Key instances and build a cryptoutil.KeySet with them.
// It returns the cryptoutil.Key representing the public signing key and the resulting cryptoutil.KeySet
func CreateKeys(sigPubKey, sigPrivKey, encPubKey, encPrivKey []byte) (cryptoutil.Key, *cryptoutil.KeySet) {
	sPubKey := cryptoutil.Key{
		ID:         kms.MockKeyID(sigPubKey, true, true),
		Value:      base58.Encode(sigPubKey),
		Alg:        cryptoutil.EdDSA,
		Capability: cryptoutil.Signature,
	}

	sPrivKey := cryptoutil.Key{
		ID:         kms.MockKeyID(sigPubKey, false, true),
		Value:      base58.Encode(sigPrivKey),
		Alg:        cryptoutil.EdDSA,
		Capability: cryptoutil.Signature,
	}

	ePubKey := cryptoutil.Key{
		ID:         kms.MockKeyID(sigPubKey, true, false),
		Value:      base58.Encode(encPubKey),
		Alg:        cryptoutil.Curve25519,
		Capability: cryptoutil.Encryption,
	}

	ePrivKey := cryptoutil.Key{
		ID:         kms.MockKeyID(sigPubKey, false, false),
		Value:      base58.Encode(encPrivKey),
		Alg:        cryptoutil.Curve25519,
		Capability: cryptoutil.Encryption,
	}

	ks := &cryptoutil.KeySet{
		ID:         kms.MockKeySetID(base58.Decode(sPubKey.Value)),
		Keys:       []cryptoutil.Key{sPubKey, sPrivKey, ePubKey, ePrivKey},
		PrimaryKey: sPubKey,
	}

	return sPubKey, ks
}

// GenerateRawKeys will generate raw signature and encryption keys using rand (randomly generated bytes, ie rand.Reader
// but can be any type implementing io.Reader)
func GenerateRawKeys(rand io.Reader) ([]byte, []byte, []byte, []byte, error) {
	sigPubKey, sigPrivKey, err := ed25519.GenerateKey(rand)
	if err != nil {
		return nil, nil, nil, nil, err
	}

	// convert signing keys to encryption keys
	encPubKey, err := cryptoutil.PublicEd25519toCurve25519(sigPubKey)
	if err != nil {
		return nil, nil, nil, nil, err
	}

	encPrivKey, err := cryptoutil.SecretEd25519toCurve25519(sigPrivKey)
	if err != nil {
		return nil, nil, nil, nil, err
	}

	return sigPubKey, sigPrivKey, encPubKey, encPrivKey, nil
}
