/*
Copyright SecureKey Technologies Inc. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package localkms

import (
	"bytes"
	"fmt"
	"os"

	"github.com/google/tink/go/aead"
	"github.com/google/tink/go/core/registry"
	"github.com/google/tink/go/keyset"
	"github.com/google/tink/go/signature"
	tinkpb "github.com/google/tink/proto/tink_go_proto"

	"github.com/hyperledger/aries-framework-go/pkg/internal/kms/localkms"
	"github.com/hyperledger/aries-framework-go/pkg/secretlock"
	"github.com/hyperledger/aries-framework-go/pkg/secretlock/local"
	"github.com/hyperledger/aries-framework-go/pkg/storage"
)

const (
	nameSpace      = "kmsdb"
	masterKeyLabel = "AGENT_MASTER_KEYURI"
)

type provider interface {
	StorageProvider() storage.Provider
}

// LocalKMS implements kms.KeyManager to provide key management capabilities using a local db.
// It uses an underlying secret lock service (default local secretLock) to wrap (encrypt) keys
// prior to storing them.
type LocalKMS struct {
	secretLock       secretlock.Service
	masterKeyURI     string
	store            storage.StoreWithDelete
	masterKeyEnvAEAD *aead.KMSEnvelopeAEAD
}

// NewKMS will will create a new
func NewKMS(p provider) (*LocalKMS, error) {
	masterKeyURI := os.Getenv(masterKeyLabel)
	if masterKeyURI == "" {
		return nil, fmt.Errorf("failed to set secretLock: masterKeyURI not set")
	}

	secretLock, err := local.NewService(masterKeyURI)
	if err != nil {
		return nil, err
	}

	s, err := p.StorageProvider().OpenStoreWithDelete(nameSpace)
	if err != nil {
		return nil, fmt.Errorf("failed to ceate local kms: %w", err)
	}

	kmsClient, err := localkms.NewClient(secretLock, masterKeyURI)
	if err != nil {
		return nil, fmt.Errorf("failed to ceate local kms client: %w", err)
	}

	// register kmsClient in Tink
	registry.RegisterKMSClient(kmsClient)

	backendAEAD, err := kmsClient.GetAEAD(masterKeyURI)
	if err != nil {
		return nil, err
	}

	// create a KMSEnvelopeAEAD instance to wrap/unwrap keys managed by LocalKMS
	masterKeyEnvAEAD := aead.NewKMSEnvelopeAEAD(*aead.XChaCha20Poly1305KeyTemplate(), backendAEAD)

	return &LocalKMS{store: s, secretLock: secretLock, masterKeyURI: masterKeyURI, masterKeyEnvAEAD: masterKeyEnvAEAD}, nil
}

// Create a new key/keyset, store it and return its stored ID and key handle
func (l *LocalKMS) Create(kt string) (string, interface{}, error) {
	if kt == "" {
		return "", nil, fmt.Errorf("failed to create new key, missing key type")
	}

	keyTemplate, err := getKeyTemplate(kt)
	if err != nil {
		return "", nil, err
	}

	kh, err := keyset.NewHandle(keyTemplate)
	if err != nil {
		return "", nil, err
	}

	kID, err := l.storeKeySet(kh)
	if err != nil {
		return "", nil, err
	}

	return kID, kh, nil
}

// Get key handle for the given keyID
func (l *LocalKMS) Get(keyID string) (interface{}, error) {
	return l.getKeySet(keyID)
}

// Rotate a key referenced by keyID and return its updated handle
func (l *LocalKMS) Rotate(kt, keyID string) (string, interface{}, error) {
	kh, err := l.getKeySet(keyID)
	if err != nil {
		return "", nil, err
	}

	keyTemplate, err := getKeyTemplate(kt)
	if err != nil {
		return "", nil, err
	}

	km := keyset.NewManagerFromHandle(kh)

	err = km.Rotate(keyTemplate)
	if err != nil {
		return "", nil, err
	}

	updatedKH, err := km.Handle()

	if err != nil {
		return "", nil, err
	}

	err = l.store.Delete(keyID)
	if err != nil {
		return "", nil, err
	}

	newID, err := l.storeKeySet(updatedKH)
	if err != nil {
		return "", nil, err
	}

	return newID, updatedKH, nil
}

// nolint:gocyclo
func getKeyTemplate(keyType string) (*tinkpb.KeyTemplate, error) {
	switch keyType {
	case "AES128GCM":
		return aead.AES128GCMKeyTemplate(), nil
	case "AES256GCMNoPrefix":
		return aead.AES256GCMNoPrefixKeyTemplate(), nil // RAW (to support keys not generated by Tink)
	case "AES256GCM":
		return aead.AES256GCMKeyTemplate(), nil
	case "ChaCha20Poly1305":
		return aead.ChaCha20Poly1305KeyTemplate(), nil
	case "XChaCha20Poly1305":
		return aead.XChaCha20Poly1305KeyTemplate(), nil
	case "ECDSAP256":
		return signature.ECDSAP256KeyTemplate(), nil
	case "ECDSAP384":
		return signature.ECDSAP384KeyTemplate(), nil
	case "ECDSAP521":
		return signature.ECDSAP521KeyTemplate(), nil
	case "ED25519":
		return signature.ED25519KeyTemplate(), nil
	default:
		return nil, fmt.Errorf("key type unrecognized")
	}
}

func (l *LocalKMS) storeKeySet(kh *keyset.Handle) (string, error) {
	w := localkms.NewWriter(l.store, l.masterKeyURI)

	buf := new(bytes.Buffer)
	jsonKeysetWriter := keyset.NewJSONWriter(buf)

	if e := kh.Write(jsonKeysetWriter, l.masterKeyEnvAEAD); e != nil {
		return "", e
	}

	// write buffer to localstorage
	if _, e := w.Write(buf.Bytes()); e != nil {
		return "", e
	}

	return w.KeysetID, nil
}

func (l *LocalKMS) getKeySet(id string) (*keyset.Handle, error) {
	localDBReader := localkms.NewReader(l.store, id)
	jsonKeysetReader := keyset.NewJSONReader(localDBReader)

	// Read reads the encrypted keyset handle back from the io.Reader implementation
	// and decrypts it using masterKeyEnvAEAD.
	kh, err := keyset.Read(jsonKeysetReader, l.masterKeyEnvAEAD)
	if err != nil {
		return nil, err
	}

	return kh, nil
}
